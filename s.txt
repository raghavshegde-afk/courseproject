// void initialize_game(Game* game) {
//     memset(game->peg_board, PLAYER_NONE, sizeof(game->peg_board));//From what I understand memset sets memory to a specific value
//     memset(game->Links, PLAYER_NONE, sizeof(game->Links));
//     game->current_turn = PLAYER_RED;
//     game->current_state = STATE_PLAYING;
// }

// void place_peg(Game* game, int row, int col, enum Player player) {
//     if (row < 0 || row >= 24 || col < 0 || col >= 24) {
//         printf("Invalid position\n");
//         return;
//     }
//     if (game->peg_board[row][col] != PLAYER_NONE) {
//         printf("Position already occupied\n");
//         return;
//     }
//     game->peg_board[row][col] = player;
// }

// void remove_peg(Game* game, int row, int col) {
//     if (game->peg_board[row][col] == PLAYER_NONE) {
//         printf("No peg to remove at this position\n");
//         return;
//     }
//     for(int k=0; k<8; k++) {
//         if(game->Links[row][col][k] != PLAYER_NONE) {
//             printf("Cannot remove peg with existing links\n");
//             return;
//         }
//     }
//     if(game->current_turn == PLAYER_RED && game->peg_board[row][col] != PLAYER_RED) {
//         printf("You can only remove your own pegs\n");
//         return;
//     }
//     if(game->current_turn == PLAYER_BLACK && game->peg_board[row][col] != PLAYER_BLACK) {
//         printf("You can only remove your own pegs\n");
//         return;
//     }
//     game->peg_board[row][col] = PLAYER_NONE;
// }

// void place_link(Game* game, int row1, int col1, int row2, int col2) {
//     // Validate positions and knight's move
//     int dr = abs(row1 - row2);
//     int r=row1-row2;
//     int c=col1-col2;
//     int dc = abs(col1 - col2);
//     if (!((dr == 2 && dc == 1) || (dr == 1 && dc == 2))) {
//         printf("Links can only be placed in a knight's move pattern\n");
//         return;
//     }
//     // Make sure link doesnt intersect another one
//     if(r==2&&c==1){
//         if(game->Links[row1-1][col1-1][3]!=PLAYER_NONE||game->Links[row1-1][col1-1][5]!=PLAYER_NONE||game->Links[row1-2][col1-1][1]!=PLAYER_NONE||game->Links[row1][col1-1][1]!=PLAYER_NONE||game->Links[row1][col1-1][1]!=PLAYER_NONE||game->Links[row1-1][col1][6]!=PLAYER_NONE||game->Links[row1-1][col1][4]!=PLAYER_NONE||game->Links[row1-1][col1][2]!=PLAYER_NONE||game->Links[row1-2][col1][6]!=PLAYER_NONE||game->Links[row1][col1][4]!=PLAYER_NONE){
//             printf("Link intersects another link\n");
//             return;
//         }
//     }
//     if(r==2&&c==-1){
//         if(game->Links[row1-1][col1+1][2]!=PLAYER_NONE||game->Links[row1-1][col1+1][4]!=PLAYER_NONE||game->Links[row1-2][col1+1][0]!=PLAYER_NONE||game->Links[row1][col1+1][0]!=PLAYER_NONE||game->Links[row1][col1+1][0]!=PLAYER_NONE||game->Links[row1-1][col1][7]!=PLAYER_NONE||game->Links[row1-1][col1][5]!=PLAYER_NONE||game->Links[row1-1][col1][3]!=PLAYER_NONE||game->Links[row1-2][col1][7]!=PLAYER_NONE||game->Links[row1][col1][5]!=PLAYER_NONE){
//             printf("Link intersects another link\n");
//             return;
//         }
//     }
//     if(r==1&&c==2){
//         if(game->Links[row1-1][col1-1][5]!=PLAYER_NONE||game->Links[row1-1][col1-1][7]!=PLAYER_NONE||game->Links[row1-1][col1-2][0]!=PLAYER_NONE||game->Links[row1-1][col1][0]!=PLAYER_NONE||game->Links[row1-1][col1][0]!=PLAYER_NONE||game->Links[row1][col1-1][3]!=PLAYER_NONE||game->Links[row1][col1-1][1]!=PLAYER_NONE||game->Links[row1][col1-1][7]!=PLAYER_NONE||game->Links[row1][col1-2][3]!=PLAYER_NONE||game->Links[row1][col1][1]!=PLAYER_NONE){
//             printf("Link intersects another link\n");
//             return;
//         }
//     }
//     if(r==1&&c==-2){
//         if(game->Links[row1-1][col1+1][4]!=PLAYER_NONE||game->Links[row1-1][col1+1][6]!=PLAYER_NONE||game->Links[row1-1][col1+2][1]!=PLAYER_NONE||game->Links[row1-1][col1][1]!=PLAYER_NONE||game->Links[row1-1][col1][1]!=PLAYER_NONE||game->Links[row1][col1+1][2]!=PLAYER_NONE||game->Links[row1][col1+1][0]!=PLAYER_NONE||game->Links[row1][col1+1][6]!=PLAYER_NONE||game->Links[row1][col1+2][2]!=PLAYER_NONE||game->Links[row1][col1][0]!=PLAYER_NONE){
//             printf("Link intersects another link\n");
//             return;
//         }
//     }
//     if(r<0){
//         place_link(game, row2, col2, row1, col1);
//         return;
//     }
//     // Check if both pegs exist
//     if (game->peg_board[row1][col1] == PLAYER_NONE || game->peg_board[row2][col2] == PLAYER_NONE) {
//         printf("Both positions must have pegs to place link\n");
//         return;
//     }
//     if (game->peg_board[row1][col1] != game->current_turn || game->peg_board[row2][col2] != game->current_turn) {
//         printf("You can only link your own pegs\n");
//         return;
//     }
//     // Place link
//     for (int i = 0; i < 8; i++) {
//         if (KNIGHT_MOVES_R[i] == row2 - row1 && KNIGHT_MOVES_C[i] == col2 - col1) {
//             game->Links[row1][col1][i] = game->current_turn;
//             game->Links[row2][col2][7-i] = game->current_turn; // Opposite direction
//             return;
//         }
//     }
// }

// void remove_link(Game* game, int row1, int col1, int row2, int col2) {
//     // Validate positions and knight's move
//     int dr = abs(row1 - row2);
//     int dc = abs(col1 - col2);
//     if (!((dr == 2 && dc == 1) || (dr == 1 && dc == 2))) {
//         printf("Links can only be removed in a knight's move pattern\n");
//         return;
//     }
//     // Check if link exists
//     int link_exists = 0;
//     for (int i = 0; i < 8; i++) {
//         if (KNIGHT_MOVES_R[i] == row2 - row1 && KNIGHT_MOVES_C[i] == col2 - col1) {
//             if (game->Links[row1][col1][i] != PLAYER_NONE) {
//                 link_exists = 1;
//                 break;
//             }
//         }
//     }
//     if (!link_exists) {
//         printf("No link exists between specified positions\n");
//         return;
//     }
//     if (game->peg_board[row1][col1] != game->current_turn || game->peg_board[row2][col2] != game->current_turn) {
//         printf("You can only remove links from your own pegs\n");
//         return;
//     }
//     // Remove link
//     for (int i = 0; i < 8; i++) {
//         if (KNIGHT_MOVES_R[i] == row2 - row1 && KNIGHT_MOVES_C[i] == col2 - col1) {
//             game->Links[row1][col1][i] = PLAYER_NONE;
//             game->Links[row2][col2][7-i] = PLAYER_NONE; // opposite direction
//             return;
//         }
//     }
// }
// void print_board(Game* game) {
//     memset(print, ' ', sizeof(print));

//     for(int i=0;i<24;i++){
//         for(int j=0;j<24;j++){
//             for(int k=0;k<8;k++){
//                 if(game->peg_board[i][j]==PLAYER_RED){
//                     print[i*2][j*4]= 'R';
//                     if(game->Links[i][j][k]==PLAYER_RED){
                        
                    
//                         if(k==0){
//                             print[i*2-1][j*4-1] = '\\';
//                             print[i*2-2][j*4-2] = '\\';
//                             print[i*2-3][j*4-3] = '\\';
//                         }
//                         else if(k==1){
//                             print[i*2-1][j*4+1] = '/';
//                             print[i*2-2][j*4+2] = '/';
//                             print[i*2-3][j*4+3] = '/';

//                         }
//                         else if(k==2){
//                             print[i*2-1][4*(j-1)] = '\\';
                            
//                         }
//                         else if(k==3){
//                             print[i*2-1][(j+1)*4] = '/';
//                         }
//                         else if(k==4){
//                             print[i*2+1][(j-1)*4] = '/';
//                         }
//                         else if(k==5){
//                             print[i*2+1][(j+1)*4] = '\\';
//                         }
//                         else if(k==6){
//                             print[i*2+1][j*4-1] = '/';
//                             print[i*2+2][j*4-2] = '/';
//                             print[i*2+3][j*4-3] = '/';
                            
//                         }
//                         else if(k==7){
//                             print[i*2+1][j*4+1] = '\\';
//                             print[i*2+2][j*4+2] = '\\';
//                             print[i*2+3][j*4+3] = '\\';
//                         }
//                     }
//                 } else if(game->peg_board[i][j]==PLAYER_BLACK){
//                     print[i*2][j*4]= 'B';
//                     if(game->Links[i][j][k]==PLAYER_BLACK){

//                         if(k==0){
//                             print[i*2-1][j*(4-1)] = '\\';
//                         }
//                         else if(k==1){
//                             print[i*2+1][j*(4-1)] = '/';
//                         }
//                         else if(k==2){
//                             print[i*2-1][j*4-1] = '\\';
//                             print[i*2-2][j*4-2] = '\\';
//                             print[i*2-3][j*4-3] = '\\';
//                         }
//                         else if(k==3){
//                             print[i*2-3][j*4+1] = '/';
//                             print[i*2-2][j*4+2] = '/';
//                             print[i*2-3][j*4+3] = '/';
//                         }
//                         else if(k==4){
//                             print[i*2+1][j*4+1] = '\\';
//                             print[i*2+2][j*4+2] = '\\';
//                             print[i*2+3][j*4+3] = '\\';
//                         }
//                         else if(k==5){
//                             print[i*2+1][j*4-1] = '/';
//                             print[i*2+2][j*4-2] = '/';
//                             print[i*2+3][j*4-3] = '/';
//                         }
//                         else if(k==6){
//                             print[i*2+1][j*(4+1)] = '\\';
//                         }
//                         else if(k==7){
//                             print[i*2-1][j*(4-1)] = '/';
//                         }
                        
                    
                    
//                     }
                    
//                 }
//                 else{
//                     print[i*2][j*4]= '.';
//                 }
//             }
//         }
//     }
// }

// void show_board(Game* game){
//     print_board(game);
//     for(int i=0;i<47;i++){
//         for(int j=0;j<93;j++){
//             printf("%c",print[i][j]);
//         }
//         printf("\n");
//     }
// }

// void change_turn(Game* game) {
//     if (game->current_turn == PLAYER_RED) {
//         game->current_turn = PLAYER_BLACK;
//     } else {
//         game->current_turn = PLAYER_RED;
//     }
// }


// int find_win_path(Game* game, enum Player player, int r, int c, int visited[24][24]) {

//     // Check if this peg is a "win"
//     if (player == PLAYER_RED && c == 23) {
//         return 1; // Red wins by reaching column 23
//     }
//     if (player == PLAYER_BLACK && r == 23) {
//         return 1; // Black wins by reaching row 23
//     }

//     //  Mark this peg as visited
//     visited[r][c] = 1;

//     //  Visit all linked neighbors
//     for (int k = 0; k < 8; k++) {
//         // Check if a link exists and belongs to the current player
//         if (game->Links[r][c][k] == player) {
//             int next_r = r + KNIGHT_MOVES_R[k];
//             int next_c = c + KNIGHT_MOVES_C[k];

//             // Bounds check (ensure we are still on the board)
//             if (next_r >= 0 && next_r < 24 && next_c >= 0 && next_c < 24) {
                
//                 // Check if the neighbor has NOT been visited yet
//                 if (visited[next_r][next_c] == 0) {
                    
//                     // Recursive call
//                     if (find_win_path(game, player, next_r, next_c, visited)) {
//                         return 1; // Found a path
//                     }
//                 }
//             }
//         }
//     }

//     // No path found from this peg
//     return 0;
// }

// void check_gamestate(Game* game) {
//     int visited[24][24]; // Array to prevent loops
    
//     if (game->current_turn == PLAYER_RED) {
//         for (int i = 1; i < 23; i++) {
//             // Start a search from every RED peg in col 0
//             if (game->peg_board[i][0] == PLAYER_RED) {
//                 memset(visited, 0, sizeof(visited)); // Reset visited to all zeroes
//                 if (find_win_path(game, PLAYER_RED, i, 0, visited)) {
//                     game->current_state = STATE_RED_WINS;
//                     return;
//                 }
//             }
//         }
//     } else { // PLAYER_BLACK
//         for (int j = 1; j < 23; j++) {
//             // Start a search from every BLACK peg in row 0
//             if (game->peg_board[0][j] == PLAYER_BLACK) {
//                 memset(visited, 0, sizeof(visited)); // Reset visited to all zeroes
//                 if (find_win_path(game, PLAYER_BLACK, 0, j, visited)) {
//                     game->current_state = STATE_BLACK_WINS;
//                     return;
//                 }
//             }
//         }
//     }
// }
// void print_player_prompt(enum Player player) {
//     if (player == PLAYER_RED) {
//         printf("Red's turn. Enter your move:\n");
//     } else if (player == PLAYER_BLACK) {
//         printf("Black's turn. Enter your move:\n");
//     }
// }
// void print_winner(Game* game) {
//     if (game->current_state == STATE_RED_WINS) {
//         printf("Red wins!\n");
//     } else if (game->current_state == STATE_BLACK_WINS) {
//         printf("Black wins!\n");
//     } else {
//         printf("Game is still ongoing.\n");
//     } 
// }